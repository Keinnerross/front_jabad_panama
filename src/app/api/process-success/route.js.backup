import Stripe from 'stripe';

// Fix para certificados self-signed en desarrollo
if (process.env.NODE_ENV === 'development') {
  process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';
}

import { getNotificationEmail, validateEmailConfig, logNotification, handleNotificationError } from '../../utils/siteConfigHelper.js';
import { sendDonationNotification, sendOrderNotification, sendUserOrderConfirmation, sendUserDonationConfirmation } from '../../services/emailService.js';
import { formatCustomerInfo, parseLineItems, calculateTotal } from '../../utils/siteConfigHelper.js';

const stripe = new Stripe(process.env.STRIPE_SECRET_KEY);

// In-memory store to track processed sessions (in production, use Redis or database)
const processedSessions = new Set();

export async function POST(request) {
  try {
    // Check if we should process payments here (only in development/non-webhook mode)
    const useWebhookProcessing = process.env.USE_WEBHOOK_PROCESSING === 'true';
    
    if (useWebhookProcessing) {
      console.log('‚ùå Process-success API disabled - webhook processing is enabled');
      return Response.json({ 
        error: 'Payment processing is handled by webhook in this environment' 
      }, { status: 400 });
    }

    console.log('üîÑ Process-success API enabled for development mode');
    
    const { sessionId } = await request.json();
    
    if (!sessionId) {
      return Response.json({ error: 'Session ID is required' }, { status: 400 });
    }

    // Check if already processed
    if (processedSessions.has(sessionId)) {
      console.log('‚ÑπÔ∏è Session already processed:', sessionId);
      return Response.json({ success: true, message: 'Session already processed', alreadyProcessed: true });
    }

    console.log('üîÑ Processing success for session:', sessionId);

    // Mark as processed immediately
    processedSessions.add(sessionId);

    // Retrieve session from Stripe con line_items expandidos y productos
    const session = await stripe.checkout.sessions.retrieve(sessionId, {
      expand: ['line_items', 'line_items.data.price.product']
    });
    
    if (!session) {
      // Remove from processed set if session not found
      processedSessions.delete(sessionId);
      return Response.json({ error: 'Session not found' }, { status: 404 });
    }

    try {
      // Process the session the same way as webhook
      await handleCheckoutSessionCompleted(session);
      return Response.json({ success: true, message: 'Payment processed successfully' });
    } catch (processingError) {
      // Remove from processed set if processing failed
      processedSessions.delete(sessionId);
      throw processingError;
    }
    
  } catch (error) {
    console.error('Error processing success:', error);
    return Response.json({ error: 'Processing failed', details: error.message }, { status: 500 });
  }
}

// Copy the same logic from webhook
async function handleCheckoutSessionCompleted(session) {
  console.log('Processing checkout session:', session.id);
  
  try {
    // Obtener email de notificaci√≥n
    const notificationEmail = await getNotificationEmail();
    
    if (session.mode === 'subscription') {
      // Manejar suscripciones (donaciones recurrentes)
      const subscription = await stripe.subscriptions.retrieve(session.subscription);
      console.log('Subscription created:', subscription.id);
      
      // Obtener metadata de la sesi√≥n
      const metadata = session.metadata || {};
      
      // Si es una suscripci√≥n limitada, agregar metadata a la suscripci√≥n
      if (metadata.subscriptionType === 'limited' && metadata.maxPayments) {
        await stripe.subscriptions.update(subscription.id, {
          metadata: {
            ...metadata,
            paymentsCount: '0', // Inicializar contador
            createdAt: new Date().toISOString()
          }
        });
      }

      // Enviar emails de confirmaci√≥n de donaci√≥n
      if (validateEmailConfig() && notificationEmail) {
        const customerInfo = {
          email: session.customer_email || session.customer_details?.email || 'unknown@email.com',
          firstName: metadata.customer_firstName || '',
          lastName: metadata.customer_lastName || '',
          phone: metadata.customer_phone || '',
          nationality: metadata.customer_nationality || ''
        };

        const donationData = {
          customer: customerInfo,
          amount: session.amount_total / 100, // Convertir de centavos
          frequency: metadata.frequency || 'monthly',
          donationType: 'subscription',
          metadata: {
            ...metadata,
            sessionId: session.id,
            subscriptionId: subscription.id
          }
        };

        // Enviar notificaci√≥n al admin
        const adminResult = await sendDonationNotification(notificationEmail, donationData);
        if (adminResult.success) {
          logNotification('DONATION', notificationEmail, donationData);
        } else {
          handleNotificationError(adminResult.error, 'admin donation notification');
        }

        // Enviar confirmaci√≥n al usuario
        const userResult = await sendUserDonationConfirmation(customerInfo.email, donationData);
        if (userResult.success) {
          logNotification('USER_DONATION_CONFIRMATION', customerInfo.email, donationData);
        } else {
          handleNotificationError(userResult.error, 'user donation confirmation');
        }

        // Guardar donaci√≥n de suscripci√≥n en Strapi despu√©s de emails exitosos
        const strapiResult = await saveDonationToStrapi(session, metadata, 'subscription');
        if (strapiResult) {
          console.log('‚úÖ Subscription donation successfully saved to Strapi:', strapiResult.data?.documentId);
        }
      }

    } else if (session.mode === 'payment') {
      // Manejar pagos √∫nicos (pedidos/donaciones √∫nicas)
      const metadata = session.metadata || {};
      
      if (validateEmailConfig() && notificationEmail) {
        const customerInfo = {
          email: session.customer_email || session.customer_details?.email || 'unknown@email.com',
          firstName: metadata.customer_firstName || '',
          lastName: metadata.customer_lastName || '',
          phone: metadata.customer_phone || '',
          nationality: metadata.customer_nationality || ''
        };

        // Verificar si es donaci√≥n √∫nica o pedido regular
        const isDonation = metadata.purpose === 'Donation' || 
                          metadata.donationType === 'one-time';

        if (isDonation) {
          // Enviar emails de donaci√≥n √∫nica
          const donationData = {
            customer: customerInfo,
            amount: session.amount_total / 100,
            frequency: 'one-time',
            donationType: 'one-time',
            metadata: {
              ...metadata,
              sessionId: session.id
            }
          };

          // Notificaci√≥n al admin
          const adminResult = await sendDonationNotification(notificationEmail, donationData);
          if (adminResult.success) {
            logNotification('DONATION', notificationEmail, donationData);
          } else {
            handleNotificationError(adminResult.error, 'admin donation notification');
          }

          // Confirmaci√≥n al usuario
          const userResult = await sendUserDonationConfirmation(customerInfo.email, donationData);
          if (userResult.success) {
            logNotification('USER_DONATION_CONFIRMATION', customerInfo.email, donationData);
          } else {
            handleNotificationError(userResult.error, 'user donation confirmation');
          }

          // Guardar donaci√≥n en Strapi despu√©s de emails exitosos
          const strapiResult = await saveDonationToStrapi(session, metadata, 'one-time');
          if (strapiResult) {
            console.log('‚úÖ Donation successfully saved to Strapi:', strapiResult.data?.documentId);
          }

        } else {
          // Enviar emails de pedido regular
          // Usar line_items de la sesi√≥n expandida si est√°n disponibles
          const items = session.line_items?.data ? 
            parseLineItems(session.line_items.data) : 
            [{ name: 'Order', price: session.amount_total / 100, quantity: 1 }];
          
          // Enriquecer items con informaci√≥n espec√≠fica por tipo de producto desde metadata
          const enrichedItems = items.map(item => {
            const enrichedItem = { ...item };
            
            // Para reservas de comidas
            if (item.productType === 'mealReservation' || metadata.orderType === 'reservation') {
              enrichedItem.shabbatName = metadata.eventName || metadata.shabbatName || extractEventNameFromDescription(item.description);
              enrichedItem.shabbatDate = metadata.eventDate || metadata.shabbatDate || metadata.serviceDate;
              enrichedItem.eventType = 'Shabbat Meal';
            }
            
            // Para Shabbat Box
            if (item.productType === 'shabbatBox' || metadata.orderType === 'shabbatBox') {
              enrichedItem.shabbatName = metadata.parashahName || extractParashahFromDescription(item.description);
              enrichedItem.shabbatDate = metadata.deliveryDate || metadata.shabbatDate;
              enrichedItem.eventType = 'Shabbat Box Delivery';
            }
            
            return enrichedItem;
          });
          
          const total = calculateTotal(enrichedItems, metadata.donation);
          
          const orderData = {
            orderId: metadata.orderId || `ORDER-${session.id}`,
            customer: customerInfo,
            items: enrichedItems,
            total,
            metadata: {
              ...metadata,
              sessionId: session.id
            }
          };

          // Notificaci√≥n al admin
          const adminResult = await sendOrderNotification(notificationEmail, orderData);
          if (adminResult.success) {
            logNotification('ORDER', notificationEmail, orderData);
          } else {
            handleNotificationError(adminResult.error, 'admin order notification');
          }

          // Confirmaci√≥n al usuario
          const userResult = await sendUserOrderConfirmation(customerInfo.email, orderData);
          if (userResult.success) {
            logNotification('USER_ORDER_CONFIRMATION', customerInfo.email, orderData);
          } else {
            handleNotificationError(userResult.error, 'user order confirmation');
          }

          // Guardar orden en Strapi despu√©s de emails exitosos  
          // Pasar los items enriquecidos que tienen la informaci√≥n completa
          const strapiResult = await saveOrderToStrapi(session, metadata, enrichedItems);
          if (strapiResult) {
            console.log('‚úÖ Order successfully saved to Strapi:', strapiResult.data?.documentId);
          }
        }
      }
    }
  } catch (error) {
    console.error('Error in handleCheckoutSessionCompleted:', error);
    handleNotificationError(error, 'checkout session completed handler');
    throw error; // Re-throw to be handled by the main function
  }
}

// Helper para guardar donaciones en Strapi
async function saveDonationToStrapi(session, metadata, donationType) {
  try {
    console.log('üìù Attempting to save donation to Strapi...');
    console.log('Session data:', { 
      id: session.id, 
      amount: session.amount_total / 100,
      email: session.customer_email,
      subscription: session.subscription 
    });
    console.log('Metadata:', metadata);
    
    // Generar ID √∫nico para la donaci√≥n
    const donationId = `DON-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
    
    // Determinar el tipo de donaci√≥n y meses personalizados
    let finalDonationType = metadata.frequency || donationType || 'one-time';
    let finalCustomMonths = null;
    let finalIsDonationCustom = false;
    
    // Manejar casos especiales de 12 y 24 meses
    if (metadata.frequency === '12-months') {
      finalDonationType = 'Custom';
      finalCustomMonths = 12;
      finalIsDonationCustom = true;
    } else if (metadata.frequency === '24-months') {
      finalDonationType = 'Custom';
      finalCustomMonths = 24;
      finalIsDonationCustom = true;
    } else if (metadata.frequency === 'other' && metadata.customMonths) {
      finalDonationType = 'Custom';
      finalCustomMonths = parseInt(metadata.customMonths);
      finalIsDonationCustom = true;
    } else if (metadata.selectedPresetAmount === 'custom') {
      finalIsDonationCustom = true;
    }
    
    const donationData = {
      data: {
        donationId: donationId,
        subscriptionId: session.subscription || null,
        donorEmail: session.customer_email || session.customer_details?.email || 'unknown@email.com',
        totalAmount: session.amount_total / 100,
        donationType: finalDonationType,
        customMonths: finalCustomMonths,
        isDonationCustom: finalIsDonationCustom,
        donationStatus: 'completed'
      }
    };
    
    console.log('üì§ Sending to Strapi:', JSON.stringify(donationData, null, 2));

    // Usar URL interna para server-side requests
    const strapiUrl = process.env.STRAPI_INTERNAL_URL || process.env.STRAPI_API_URL;
    const response = await fetch(`${strapiUrl}/api/donations`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.STRAPI_API_TOKEN}`
      },
      body: JSON.stringify(donationData)
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Strapi error response:', errorText);
      console.error('‚ùå Status:', response.status);
      throw new Error(`Strapi API error: ${response.status} - ${errorText}`);
    }

    const result = await response.json();
    console.log('‚úÖ Donation saved to Strapi:', result.data?.donationId);
    return result;

  } catch (error) {
    console.error('‚ùå Error saving donation to Strapi:', error);
    handleNotificationError(error, 'donation save to Strapi');
    return null;
  }
}

// Helper para guardar √≥rdenes en Strapi
async function saveOrderToStrapi(session, metadata, parsedItems) {
  try {
    // Solo guardar para reservaciones y shabbatBox (no donaciones)
    if (metadata.purpose === 'Donation') {
      return null;
    }

    const orderType = detectOrderType(metadata, parsedItems);
    
    // Logs para debugging del routing de √≥rdenes
    console.log('üîç saveOrderToStrapi received:', {
      metadata_orderType: metadata.orderType,
      metadata_isCustomEvent: metadata.isCustomEvent,
      metadata_shabbat_name: metadata.shabbat_name,
      metadata_eventName: metadata.eventName, // DEBUG: Este es el nombre que deber√≠a usarse
      parsedItems_productTypes: parsedItems.map(item => ({ name: item.name, productType: item.productType })),
      detectedOrderType: orderType,
      eventNameFromMetadata: metadata.eventName || 'NOT_FOUND' // DEBUG: Verificar si llega
    });
    
    console.log('üîç Order routing - checking paths (PRIORITY ORDER):', {
      '1_hasCustomEventMarker': metadata.isCustomEvent === true,
      '2_orderTypeIsCustomEvent': orderType === 'customEvent',
      '3_isShabbatBox': orderType === 'shabbatBox',
      '4_isShabbatHoliday': orderType === 'shabbat or holiday',
      detectedOrderType: orderType,
      metadata_orderType: metadata.orderType,
      finalDecision: (metadata.isCustomEvent === true || orderType === 'customEvent') ? 'CUSTOM EVENT ‚Üí orders' :
                     orderType === 'shabbatBox' ? 'SHABBAT BOX ‚Üí orders' :
                     orderType === 'shabbat or holiday' ? 'SHABBAT/HOLIDAY ‚Üí shabbat-orders' : 'FALLBACK ‚Üí orders'
    });
    
    // Si es Custom Event, guardar en orders (igual que Shabbat Box)
    if (orderType === 'customEvent' || metadata.isCustomEvent === true) {
      console.log('üîç Taking CUSTOM EVENT route', { 
        orderType,
        isCustomEvent: metadata.isCustomEvent, 
        eventName: metadata.eventName 
      });
      return await saveCustomEventDeliveryOrder(session, metadata, parsedItems);
    }
    
    // Si es Shabbat Box, guardar en orders con campos espec√≠ficos
    if (orderType === 'shabbatBox') {
      console.log('üîç Taking SHABBAT BOX route');
      return await saveShabbatBoxOrder(session, metadata, parsedItems);
    }
    
    // Si es Shabbat/Holiday tradicional, guardar en shabbat-orders
    // IMPORTANTE: NO usar metadata.shabbat_name si ya sabemos que es Custom Event
    if (orderType === 'shabbat or holiday') {
      console.log('üîç Taking SHABBAT/HOLIDAY route');
      return await saveShabbatOrder(session, metadata, parsedItems);
    }

    // Para otros tipos, usar el flujo existente
    console.log('üîç Taking GENERAL/FALLBACK route - this might be the problem!', { orderType });
    const orderData = {
      data: {
        orderId: metadata.orderId || `ORDER-${session.id}`,
        orderType: orderType,
        totalAmount: session.amount_total / 100,
        stripeSessionId: session.id,
        customerName: `${metadata.customer_firstName || ''} ${metadata.customer_lastName || ''}`.trim() || 'N/A',
        customerEmail: session.customer_email || session.customer_details?.email || 'unknown@email.com',
        customerPhone: metadata.customer_phone || null,
        customerNationality: metadata.customer_nationality || null,
        serviceDate: extractServiceDate(metadata, parsedItems),
        orderDescription: formatOrderDescription(parsedItems, session.amount_total / 100),
        orderStatus: 'paid'
      }
    };

    const response = await fetch(`${process.env.STRAPI_API_URL}/api/orders`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.STRAPI_API_TOKEN}`
      },
      body: JSON.stringify(orderData)
    });

    if (!response.ok) {
      throw new Error(`Strapi API error: ${response.status}`);
    }

    const result = await response.json();
    console.log('‚úÖ Order saved to Strapi:', result.data?.orderId);
    return result;

  } catch (error) {
    console.error('‚ùå Error saving order to Strapi:', error);
    handleNotificationError(error, 'order save to Strapi');
    return null;
  }
}

// Helper para guardar √≥rdenes de Shabbat/Holiday
async function saveShabbatOrder(session, metadata, parsedItems) {
  try {
    // Ya no usamos shabbatOrderData del metadata, usamos parsedItems directamente
    console.log('üìù Processing Shabbat order from parsed items:', parsedItems);
    console.log('üìù Session line_items:', session.line_items?.data?.length, 'items');
    
    // Si parsedItems viene como un solo "Order" o como "Product", intentar obtener los items reales
    if (session.line_items?.data && (
      (parsedItems.length === 1 && parsedItems[0].name === 'Order') ||
      parsedItems.some(item => item.name === 'Product')
    )) {
      console.log('üìù Re-parsing line items from session...');
      console.log('üìù Raw line_items data:', JSON.stringify(session.line_items.data, null, 2));
      
      // Expandir la informaci√≥n del producto si es necesario
      const expandedItems = [];
      for (const item of session.line_items.data) {
        // Log detallado del item
        console.log('üìù Processing line item:', {
          description: item.description,
          price: item.price,
          price_data: item.price?.product?.name,
          amount_total: item.amount_total,
          quantity: item.quantity
        });
        
        expandedItems.push(item);
      }
      
      parsedItems = parseLineItems(expandedItems);
      console.log('üìù Re-parsed items:', parsedItems);
    }
    
    // Inicializar estructuras para las comidas
    const fridayDinner = {
      supporter_quantity: 0,
      supporter_price: 180,
      adult_quantity: 0,
      adult_price: 62,
      kids_3_10_quantity: 0,
      kids_3_10_price: 42,
      baby_1_2_quantity: 0,
      baby_1_2_price: 1,
      idf_soldier_quantity: 0,
      idf_soldier_price: 22,
      subtotal: 0,
      total_people: 0
    };
    
    const shabbatLunch = {
      supporter_quantity: 0,
      supporter_price: 180,
      adult_quantity: 0,
      adult_price: 56, // Precio diferente para el lunch
      kids_3_10_quantity: 0,
      kids_3_10_price: 42,
      baby_1_2_quantity: 0,
      baby_1_2_price: 1,
      idf_soldier_quantity: 0,
      idf_soldier_price: 22,
      subtotal: 0,
      total_people: 0
    };
    
    // Procesar cada item desde parsedItems
    parsedItems?.forEach(item => {
      console.log('Processing cart item:', item);
      
      let targetMeal = null;
      
      // El nombre ahora viene como "Friday Day Dinner - Adult" o "Shabbat Lunch - Kids 3-10 Yo"
      const fullName = (item.name || item.meal || '').toLowerCase();
      console.log('Processing item name:', fullName);
      
      // Determinar a qu√© comida pertenece
      if (fullName.includes('friday') || fullName.includes('dinner')) {
        targetMeal = fridayDinner;
      } else if (fullName.includes('lunch') || fullName.includes('shabbat lunch')) {
        targetMeal = shabbatLunch;
      }
      
      if (targetMeal) {
        // El tipo de precio est√° despu√©s del gui√≥n en el nombre
        const priceType = fullName.toLowerCase();
        
        // Obtener el precio unitario
        const unitPrice = item.price || item.unitPrice || 0;
        
        // Detectar el tipo espec√≠fico (viene despu√©s del gui√≥n)
        if (priceType.includes('supporter')) {
          targetMeal.supporter_quantity += item.quantity;
          targetMeal.supporter_price = unitPrice || targetMeal.supporter_price;
        } else if (priceType.includes('adult') && !priceType.includes('supporter')) {
          targetMeal.adult_quantity += item.quantity;
          targetMeal.adult_price = unitPrice || targetMeal.adult_price;
        } else if (priceType.includes('kids') || priceType.includes('3-10')) {
          targetMeal.kids_3_10_quantity += item.quantity;
          targetMeal.kids_3_10_price = unitPrice || targetMeal.kids_3_10_price;
        } else if (priceType.includes('baby') || priceType.includes('0-2')) {
          targetMeal.baby_1_2_quantity += item.quantity;
          targetMeal.baby_1_2_price = unitPrice || targetMeal.baby_1_2_price;
        } else if (priceType.includes('idf') || priceType.includes('soldier')) {
          targetMeal.idf_soldier_quantity += item.quantity;
          targetMeal.idf_soldier_price = unitPrice || targetMeal.idf_soldier_price;
        }
        
        // Calcular subtotal y total de personas
        const itemTotal = item.quantity * unitPrice;
        targetMeal.subtotal += itemTotal;
        targetMeal.total_people += item.quantity;
      }
    });
    
    // Procesar fecha del formato DD-DD/MM/YYYY o DD/MM/YYYY
    let startDate, endDate;
    
    if (metadata.eventDate) {
      // Si el formato es DD-DD/MM/YYYY (ej: 29-30/10/2025)
      const dateMatch = metadata.eventDate.match(/(\d{2})-(\d{2})\/(\d{2})\/(\d{4})/);
      if (dateMatch) {
        const [, startDay, endDay, month, year] = dateMatch;
        startDate = new Date(year, month - 1, startDay);
        endDate = new Date(year, month - 1, endDay);
      } else {
        // Si es formato simple DD/MM/YYYY
        const parts = metadata.eventDate.split('/');
        if (parts.length === 3) {
          startDate = new Date(parts[2], parts[1] - 1, parts[0]);
          endDate = new Date(startDate);
          endDate.setDate(endDate.getDate() + 1);
        }
      }
    }
    
    // Fallback a fecha actual si no hay fecha v√°lida
    if (!startDate) {
      startDate = new Date();
      endDate = new Date(startDate);
      endDate.setDate(endDate.getDate() + 1);
    }
    
    const shabbatOrder = {
      data: {
        orderId: metadata.orderId || `SHB-${Date.now()}`,
        shabbat_name: metadata.shabbat_name || metadata.eventName || 'Shabbat',
        startDate: startDate.toISOString().split('T')[0],
        endDate: endDate.toISOString().split('T')[0],
        customerName: `${metadata.customer_firstName || ''} ${metadata.customer_lastName || ''}`.trim(),
        customerEmail: session.customer_email || session.customer_details?.email,
        customerPhone: metadata.customer_phone || session.customer_details?.phone || '',
        customerNationality: metadata.customer_nationality || '',
        totalAmount: session.amount_total / 100,
        paymentStatus: 'paid',
        stripeSessionId: session.id,
        // SIEMPRE enviar los objetos completos, no null
        friday_dinner_details: fridayDinner,
        shabbat_lunch_details: shabbatLunch,
        // NO incluir saturday_night_details - el campo no existe en Strapi
        notes: metadata.notes || ''
      }
    };
    
    console.log('üì§ Sending Shabbat order to Strapi:', JSON.stringify(shabbatOrder, null, 2));
    
    // Usar URL interna para server-side requests
    const strapiUrl = process.env.STRAPI_INTERNAL_URL || process.env.STRAPI_API_URL;
    const response = await fetch(`${strapiUrl}/api/shabbat-orders`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.STRAPI_API_TOKEN}`
      },
      body: JSON.stringify(shabbatOrder)
    });
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Shabbat order error response:', errorText);
      throw new Error(`Strapi shabbat-orders error: ${response.status}`);
    }
    
    const result = await response.json();
    console.log('‚úÖ Shabbat order saved to Strapi:', result.data?.documentId);
    return result;
    
  } catch (error) {
    console.error('‚ùå Error saving shabbat order:', error);
    // No lanzar error para no bloquear el proceso
    return null;
  }
}

// Helper para guardar √≥rdenes de Shabbat Box
async function saveShabbatBoxOrder(session, metadata, parsedItems) {
  try {
    // Extraer informaci√≥n de delivery desde metadata y items
    const firstItem = parsedItems[0] || {};
    const deliveryType = metadata.deliveryType || firstItem.deliveryType || 'pickup';
    const deliveryAddress = metadata.deliveryAddress || firstItem.deliveryAddress || null;
    const shabbatName = metadata.shabbat_name || firstItem.shabbatName || 'Shabbat';
    
    // Procesar fechas para Shabbat Box
    let shabbatStart, shabbatEnd;
    
    // PRIMERO: Verificar si ya vienen las fechas formateadas en metadata
    if (metadata.shabbatHolidayStart && metadata.shabbatHolidayEnd) {
      // Usar directamente las fechas ya formateadas
      shabbatStart = metadata.shabbatHolidayStart;
      shabbatEnd = metadata.shabbatHolidayEnd;
      console.log('üì¶ Using pre-formatted dates from metadata:', {
        shabbatStart,
        shabbatEnd
      });
    } else {
      // FALLBACK: Procesar eventDate si no vienen las fechas formateadas
      const dateString = metadata.eventDate || firstItem.shabbatDate || metadata.shabbatDate;
      
      console.log('üì¶ Shabbat Box date processing from eventDate:', {
        dateString,
        metadata_eventDate: metadata.eventDate,
        firstItem_shabbatDate: firstItem.shabbatDate,
        metadata_shabbatDate: metadata.shabbatDate
      });
      
      let startDate, endDate;
      
      if (dateString) {
        // Si el formato es DD-DD/MM/YYYY (ej: 12-13/09/2025)
        const dateMatch = dateString.match(/(\d{2})-(\d{2})\/(\d{2})\/(\d{4})/);
        if (dateMatch) {
          const [, startDay, endDay, month, year] = dateMatch;
          startDate = new Date(year, month - 1, startDay);
          endDate = new Date(year, month - 1, endDay);
        } else {
          // Si es formato simple DD/MM/YYYY
          const parts = dateString.split('/');
          if (parts.length === 3) {
            startDate = new Date(parts[2], parts[1] - 1, parts[0]);
            endDate = new Date(startDate);
            endDate.setDate(endDate.getDate() + 1);
          }
        }
      }
      
      // Fallback a fecha actual si no hay fecha v√°lida
      if (!startDate) {
        startDate = new Date();
        endDate = new Date(startDate);
        endDate.setDate(endDate.getDate() + 1);
      }
      
      // Convertir a formato ISO para Strapi
      shabbatStart = startDate.toISOString().split('T')[0];
      shabbatEnd = endDate.toISOString().split('T')[0];
    }
    
    console.log('üì¶ Shabbat Box processed dates:', {
      shabbatStart,
      shabbatEnd
    });
    
    const orderData = {
      data: {
        orderId: metadata.orderId || `SB-${Date.now()}`,
        shabbat_or_holiday: shabbatName,
        totalAmount: session.amount_total / 100,
        stripeSessionId: session.id,
        customerName: `${metadata.customer_firstName || ''} ${metadata.customer_lastName || ''}`.trim() || 'N/A',
        customerEmail: session.customer_email || session.customer_details?.email || 'unknown@email.com',
        customerPhone: metadata.customer_phone || null,
        customerNationality: metadata.customer_nationality || null,
        orderDescription: formatOrderDescription(parsedItems, session.amount_total / 100),
        orderStatus: 'paid',
        isDelivery: deliveryType === 'delivery',
        delivery_addres: deliveryAddress, // Nota: el campo en Strapi se llama 'delivery_addres' sin 's'
        typeOfDelivery: deliveryType,
        shabbat_holiday_start: shabbatStart,
        shabbat_holiday_end: shabbatEnd,
        orderType: 'shabbatBox',
        serviceDate: null // No usado en Shabbat Box
      }
    };

    console.log('üì¶ Saving Shabbat Box order to Strapi:', JSON.stringify(orderData, null, 2));
    
    // Usar URL interna para server-side requests
    const strapiUrl = process.env.STRAPI_INTERNAL_URL || process.env.STRAPI_API_URL;
    const response = await fetch(`${strapiUrl}/api/orders`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.STRAPI_API_TOKEN}`
      },
      body: JSON.stringify(orderData)
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Shabbat Box order error response:', errorText);
      console.error('‚ùå Response status:', response.status);
      console.error('‚ùå Order data that failed:', JSON.stringify(orderData, null, 2));
      // No lanzar error para no bloquear el proceso
      return null;
    }

    const result = await response.json();
    console.log('‚úÖ Shabbat Box order saved to Strapi:', result.data?.documentId);
    return result;

  } catch (error) {
    console.error('‚ùå Error saving Shabbat Box order:', error);
    handleNotificationError(error, 'Shabbat Box order save to Strapi');
    return null;
  }
}

// Helper para guardar √≥rdenes de Custom Events con Delivery
async function saveCustomEventDeliveryOrder(session, metadata, parsedItems) {
  try {
    // Extraer informaci√≥n de delivery desde metadata y items
    const firstItem = parsedItems[0] || {};
    const deliveryType = metadata.deliveryType || firstItem.deliveryType || 'pickup';
    const deliveryAddress = metadata.deliveryAddress || firstItem.deliveryAddress || null;
    const eventName = metadata.eventName || firstItem.shabbatName || 'Custom Event';
    const eventDate = metadata.eventDate || firstItem.shabbatDate || null;
    const customEventType = metadata.customEventType || firstItem.eventType || 'delivery';
    
    // Convertir fecha de DD/MM/YYYY o DD-DD/MM/YYYY a YYYY-MM-DD para serviceDate
    let serviceDateISO = null;
    if (eventDate) {
      // Primero verificar si es un rango DD-DD/MM/YYYY
      const rangeMatch = eventDate.match(/(\d{1,2})-(\d{1,2})\/(\d{2})\/(\d{4})/);
      if (rangeMatch) {
        // Si es un rango, tomar la fecha de inicio para serviceDate
        const [, startDay, , month, year] = rangeMatch;
        serviceDateISO = `${year}-${month.padStart(2, '0')}-${startDay.padStart(2, '0')}`;
      } else {
        // Si es fecha simple DD/MM/YYYY
        const parts = eventDate.split('/');
        if (parts.length === 3) {
          const [day, month, year] = parts;
          serviceDateISO = `${year}-${month.padStart(2, '0')}-${day.padStart(2, '0')}`;
        }
      }
    }
    
    const orderData = {
      data: {
        orderId: metadata.orderId || `CE-${Date.now()}`,
        shabbat_or_holiday: eventName, // Nombre del evento
        totalAmount: session.amount_total / 100,
        stripeSessionId: session.id,
        customerName: `${metadata.customer_firstName || ''} ${metadata.customer_lastName || ''}`.trim() || 'N/A',
        customerEmail: session.customer_email || session.customer_details?.email || 'unknown@email.com',
        customerPhone: metadata.customer_phone || null,
        customerNationality: metadata.customer_nationality || null,
        orderDescription: formatOrderDescription(parsedItems, session.amount_total / 100),
        orderStatus: 'paid',
        isDelivery: deliveryType === 'delivery',
        delivery_addres: deliveryAddress,
        typeOfDelivery: deliveryType,
        shabbat_holiday_start: null, // No usar para custom events
        shabbat_holiday_end: null,   // No usar para custom events
        orderType: eventName,  // Enviar el nombre real del evento (Catering Orders, Pizza & BBQ Night, etc.)
        serviceDate: serviceDateISO  // Solo serviceDate para custom events
      }
    };

    console.log('üìÖ Custom Event order data prepared:', {
      eventName,
      orderType: orderData.data.orderType,
      serviceDateOriginal: eventDate,
      serviceDateISO: serviceDateISO,
      isDelivery: orderData.data.isDelivery,
      deliveryType,
      deliveryAddress
    });
    
    console.log('üìÖ Saving Custom Event Delivery order to Strapi:', JSON.stringify(orderData, null, 2));
    
    // Usar URL interna para server-side requests
    const strapiUrl = process.env.STRAPI_INTERNAL_URL || process.env.STRAPI_API_URL;
    const response = await fetch(`${strapiUrl}/api/orders`, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${process.env.STRAPI_API_TOKEN}`
      },
      body: JSON.stringify(orderData)
    });

    if (!response.ok) {
      const errorText = await response.text();
      console.error('‚ùå Custom Event Delivery order error response:', errorText);
      console.error('‚ùå Response status:', response.status);
      console.error('‚ùå Order data that failed:', JSON.stringify(orderData, null, 2));
      // No lanzar error para no bloquear el proceso
      return null;
    }

    const result = await response.json();
    console.log('‚úÖ Custom Event Delivery order saved to Strapi:', result.data?.documentId);
    return result;

  } catch (error) {
    console.error('‚ùå Error saving Custom Event Delivery order:', error);
    handleNotificationError(error, 'Custom Event Delivery order save to Strapi');
    return null;
  }
}

// Helper para detectar tipo de orden
function detectOrderType(metadata, parsedItems) {
  console.log('üîç detectOrderType function start:', {
    metadata_orderType: metadata.orderType,
    metadata_isCustomEvent: metadata.isCustomEvent,
    parsedItems_productTypes: parsedItems.map(item => item.productType),
    parsedItemsCount: parsedItems.length
  });
  
  // PRIMERO: Verificar si es Custom Event
  if (metadata.orderType === 'customEvent' || metadata.isCustomEvent === true) {
    console.log('üîç detectOrderType: detected as customEvent');
    return 'customEvent';
  }
  
  // SEGUNDO: Verificar Shabbat Box
  if (metadata.orderType === 'shabbatBox') {
    console.log('üîç detectOrderType: detected as shabbatBox via metadata');
    return 'shabbatBox';
  }
  
  // TERCERO: Verificar si es mealReservation pero con flag de Custom Event
  if (metadata.orderType === 'mealReservation' && metadata.isCustomEvent === true) {
    console.log('üîç detectOrderType: mealReservation but has isCustomEvent flag - treating as customEvent');
    return 'customEvent';
  }
  
  // √öLTIMO: Verificar Shabbat/Holiday solo si NO es Custom Event
  if (metadata.orderType === 'reservation' || metadata.orderType === 'mealReservation') {
    console.log('üîç detectOrderType: detected as shabbat or holiday via metadata');
    return 'shabbat or holiday';
  }

  // Verificar por los nombres de productos - Custom Events primero
  const hasCustomEvent = parsedItems.some(item => 
    item.productType === 'customEvent' || item.productType === 'customEventDelivery'
  );

  console.log('üîç detectOrderType: checking for customEvent in parsedItems:', {
    hasCustomEvent,
    itemsWithProductType: parsedItems.filter(item => item.productType).map(item => ({ name: item.name, productType: item.productType }))
  });

  if (hasCustomEvent) {
    console.log('üîç detectOrderType: detected as customEvent via parsedItems');
    return 'customEvent';
  }

  // Verificar por shabbatBox
  const hasShabbatBox = parsedItems.some(item => 
    item.productType === 'shabbatBox' || 
    item.name.toLowerCase().includes('shabbat box')
  );

  if (hasShabbatBox) {
    console.log('üîç detectOrderType: detected as shabbatBox via parsedItems');
    return 'shabbatBox';
  }

  // Default para otros tipos (incluyendo mealReservation sin isCustomEvent)
  console.log('üîç detectOrderType: defaulting to shabbat or holiday - no specific type detected');
  return 'shabbat or holiday';
}

// Helper para extraer fecha de servicio
function extractServiceDate(metadata, parsedItems) {
  // Buscar fecha en diferentes ubicaciones - prioridad a eventDate
  if (metadata.eventDate) {
    return metadata.eventDate; // Mantener formato original del texto
  }
  
  // Mantener compatibilidad con shabbatDate
  if (metadata.shabbatDate) {
    return metadata.shabbatDate; // Mantener formato original del texto
  }

  // Buscar en items
  const itemWithDate = parsedItems.find(item => item.shabbatDate);
  if (itemWithDate) {
    return itemWithDate.shabbatDate; // Mantener formato original del texto
  }

  // Default a pr√≥ximo viernes en formato DD/MM/YYYY
  const nextFriday = new Date();
  nextFriday.setDate(nextFriday.getDate() + (5 - nextFriday.getDay()));
  const day = nextFriday.getDate().toString().padStart(2, '0');
  const month = (nextFriday.getMonth() + 1).toString().padStart(2, '0');
  const year = nextFriday.getFullYear();
  return `${day}/${month}/${year}`;
}

// Helper para formatear fecha para Strapi (DEPRECATED - ya no se usa)
// Ahora el campo serviceDate es texto y mantiene el formato original
function formatDateForStrapi(dateString) {
  // Esta funci√≥n ya no se usa, pero se mantiene por si hay otras partes del c√≥digo que la llamen
  return dateString; // Devolver el texto original sin conversi√≥n
}

// Helper para formatear descripci√≥n de orden
function formatOrderDescription(parsedItems, totalAmount) {
  const lines = [];
  
  parsedItems.forEach(item => {
    if (item.productType !== 'fee' && item.productType !== 'donation') {
      const unitPrice = item.price.toFixed(2);
      const totalPrice = item.total.toFixed(2);
      lines.push(`${item.name} x${item.quantity} - $${unitPrice} cada - $${totalPrice}`);
    }
  });

  // Agregar donaci√≥n si existe
  const donation = parsedItems.find(item => item.productType === 'donation');
  if (donation) {
    lines.push(`Donaci√≥n - $${donation.total.toFixed(2)}`);
  }

  // Agregar fee si existe
  const fee = parsedItems.find(item => item.productType === 'fee');
  if (fee) {
    lines.push(`Cargo por procesamiento - $${fee.total.toFixed(2)}`);
  }

  lines.push('----------------------');
  lines.push(`Total: $${totalAmount.toFixed(2)}`);

  return lines.join('\n');
}

// Helper para extraer nombre del evento de la descripci√≥n
function extractEventNameFromDescription(description) {
  if (!description) return null;
  
  // Buscar patrones como "Parashat [nombre]" o nombres espec√≠ficos
  const parashahMatch = description.match(/Parashat\s+(\w+)/i);
  if (parashahMatch) {
    return `Parashat ${parashahMatch[1]}`;
  }
  
  // Para Shabbat Box, extraer el nombre del evento
  if (description.includes('shabbatBox')) {
    return description.split(' - ')[0] || 'Shabbat';
  }
  
  return null;
}

// Helper para extraer nombre de parash√° de la descripci√≥n  
function extractParashahFromDescription(description) {
  if (!description) return null;
  
  const parashahMatch = description.match(/Parashat\s+(\w+)/i);
  return parashahMatch ? `Parashat ${parashahMatch[1]}` : null;
}